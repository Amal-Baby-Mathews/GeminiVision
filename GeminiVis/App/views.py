from django.shortcuts import render
from django.views.decorators.http import require_http_methods
from django.core.files.storage import FileSystemStorage
from .imageup import upload_and_store_data, upload_multiple_images_from_folder
import os
import sqlite3
# Create your views here.
def Base(request):
  # Your custom logic goes here
  data = "This is data generated by the custom function."
  return render(request, 'Base.html', {'data': data})
@require_http_methods(["GET", "POST"])
def upload_images(request):
    global image_id  # Declare image_id as a global variable

    # Connect to the SQLite database
    conn = sqlite3.connect(r'C:\Users\amalb\Amal Work\GeminiVision\GeminiVision\GeminiVis\product_data.db')

    # Get the maximum image_id from the database
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT MAX(image_id) FROM products")
        result = cursor.fetchone()
        if result[0] is None:
            image_id = 1
        else:
            image_id = int(result[0]) + 1
    except sqlite3.OperationalError:
        image_id = 1
    context = {}
    if request.method == 'POST':
        single_image = request.FILES.get('single_image')
        batch_images = request.FILES.getlist('batch_images')
        if single_image:
            fs = FileSystemStorage()
            filename = fs.save(single_image.name, single_image)
            image_path = fs.path(filename)
            upload_and_store_data(image_path, image_id)
            context['single_status'] = 'success'
            os.remove(image_path)

        if batch_images:
            fs = FileSystemStorage()
            for image_file in batch_images:
                filename = fs.save(image_file.name, image_file)
                image_path = fs.path(filename)
                upload_and_store_data(image_path, image_id)
                os.remove(image_path)
            context['batch_status'] = 'success'

    return render(request, 'upload_images.html', context)